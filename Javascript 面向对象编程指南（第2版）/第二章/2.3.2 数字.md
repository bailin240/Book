### 2.3.2 数字
最简单的数字类型当然就是整数了。如果我们将一个变量赋值为 1 ，并对其调用 ==typeof== 操作符，控制台就会返回字符串 "number" ;
```
var n = 1;
typeof n;
// "number"

n = 123456;
typeof n;
// "number"
```
该例中有一点值得注意，即当您第二次设置变量的值时，就无需再用到 ==var== 语句了。

浮点数（即含小数部分的数字）显然也是 ==Number== 类型的一种：
```
var n2 = 1.23;
typeof n2;
// "number"
```
当然，我们也可以直接对一个数值调用 ==typeof== ,并非一定得要事先将其赋值给变量。
```
typeof 123;
// "number"
```

### 2.2.3.1 八进制与十六进制
当一个数字以 0 开头时，就表示这是一个八进制数。例如，八进制数 0377 所代表的就是十进制数 255。
```
var n3 = 0377;
typeof n3;
// "number"

n3;
// 255
```
如您所见，例子中最后一行所输出的就是该八制数的十进制表示形式。

或许您对八进制数还不是太熟悉，但十六进制您应该不会感到陌生，因为 ==CSS== 样式表中的颜色值大多情况下就是用十六进制定义的。

在 ==CSS== 中，我们有好几种方式定义颜色，其中的两种如下所示。
- 使用十进制数分别指定R（红）、G（绿）、B（蓝）的值，取值范围都为 0~255。例如 rbg(0,0,0)代表黑色、 rgb(255,0,0)代表红色（红值达到最大值，而绿色和蓝都为 0 值）。
- 使用十六进制数，两个数位代表一种颜色，依次是 R、G、B。例如 #000000 代表黑色、 #ff0000 代表红色，因为十六进制的 ff 就等于255 。

在 ==JavaScript== 中，我们会用 0x 前缀来表示一个十六进制值（hexadecimal value,简称为 bex ）。
```
var n4 = 0x00;
typeof n4;
// "number"

n4;
// 0

var n5 = 0xff;
typeof n5;
// "number"

n5;
// 255
```
### 2.3.2.2 指数表示法
一个数字可以表示成 1e1 (或者 1e+1、1E1、1E+1)这样的指数形式，意思是在数字 1 后面加 1 个 0 ，也就是 10 。同理，2e+3 的意思是在数字 2 后面加 3 个 0，也就是 2000 。
```
1e1;
// 10

1e+1;
// 10

2e+3;
// 2000

typeof 2e+3;
// "number"
```
此外，我们也可以将 2e+3 理解为将数字 2 的小数点向右移三位。依照同理， 2e-3 也就能被理解是将数字 2 的小数点左移三位。
```
2e-3;
// 0.002

123.456E-3;
// 0.123456

typeof 2e-3;
// "number"
```
### 2.3.2.3 lnfinity
在 ==JavaScript== 中，还有一种叫做 ==lnfinity== 的特殊值。它所代表的超出了 ==JavaScript== 处理范围的数值。但 ==Infinity== 依然是一个数字，我们可以在控制台使用 ==typeof== 来测试 ==Infinity== 。当我人输入 1e308 时，一切正常，但一旦将后面的308 改成 309 就了界了。实践证明， ==JavaScript== 所能处理的理大值是 ==1.7976931348623157E+308==,而最小值为5e-624。
```
Infinity;
// "Infinity"

typeof Infinity;
// "number"

1e309;
// "Infinity"

1e308;
// "1e+308"
```
另外，任何数除以 0 的结果也是为 Infinity：
```
var a = 6 / 0;
a;
// Infinity
```
**Infinity** 表示的是最大数（或者比最大数还要大的数），那么最小数该如何表示呢？答案是在**Infinity**  之前加一个负号：
```
var i = -Infinity;
i;
// -Infinity

typeof i;
// "number"
```
这是不是意味着我们可以得到双倍的 ==Infinity== 呢？————毕竟我们可以从 0  加到 ==Infinity== ，也可以从 0 减到 ==-Infinity==。事实上这是不可能的，因为即便将下负 ==Infinity== 相加，我们也不会得到 0  ，而是会得到一个叫做 ==NaN（Not ANumber的缩写，即不是数字）的东西。
```
Infinity - Infinity;
// NaN 

-Infinit + Infinity;
// NaN 
```
另外， ==Infinity== 与其他任何操作数执行任何算术运算的结果也都等于 ==Infinity== 。
```
Infinity - 20;
// Infinity

-Infinity * 3;
// -Infinity

Infinity / 2;
// Infinity

Infinity - 999999999999999999;
// Infinity
```
### 2.3.2.4 NaN
还记得之前见过的那个叫 ==NaN== 吗？尽管该值的名字叫做 "不是数字"，但事实上它依然属于数字类型，只不过是一种特殊的数字罢了。
```
typeof NaN;
// "number"

var a = NaN;
a
// NaN
```
如果我们在算术运算中使用了不恰当的操作数，导致运算失败，该运算就会返回 ==NaN== 。例如当我们试图让数字 10 与字符 "f" 相乘时，结果就会为 ==NaN== ，因为 "f" 显然是不支持乘法运算的。
```
var a= 10 * "f";
a;
// NaN
```
而且 ==NaN== 是有传染性的，只要我们的算术中存在一个 ==NaN== ，整个运算就会失败。
```
1 + 2 + NaN
// NaN 
```