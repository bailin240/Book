## 2.3.4 布尔值
布尔类型中只有两种值：==true== 和 ==false== 。它们使用时不需加引号。
```
var b = true;
typeof b;
// "boolen"

var b = false;
typeof b;
// "boolen"
```
如果 ==true== 或 ==false== 在引号内，它就是一个字符串。
```
var b  = "true";
typeof b;
// "string"
```
### 2.3.4.1 逻辑运算答
==JavaScript== 中有三种逻辑运算符，它们都属于布尔运算。分别是：
- !————逻辑非（取反）；
- &&————逻辑与；
- ||————逻辑或；

在 ==JavaScript== 中，如果我们想描述某事物的非真状态，就可以考虑使用逻辑非运算符：
```
var  = !true;
b;
// false
```
而如果我们对 ==true== 执行两次逻辑非运算的话，其结果应该就等于原值：
```
var b = !!true;
b;
// true
```
如果我们对一个非布尔值执行逻辑运算，那么该值就在计算过程中被转换为布尔值：
```
var b = "one";
!b;
// false
```
如您所见，上例中的字符串 "one" 是先被转换为布尔值 ==true== 然后再取反的，结果为 ==false==。如果我们对它了取反两次，结果就会为==true==。例如：
```
var b  = "one";
!!b;
// true
```
借助双重取反操作，我们可以很轻易地将任何值转换为相应的布尔值。理解各种类型的值转换为相应布尔值的规则非常重要。除了下面所列出特定值以外（它们将被转换为==false==）,其余大部分值在转换为布尔值时都为 ==true==。
- 空字符串""
- null
- undefined
- 数字0
- 数字NaN
- 布尔值false
这6个值有时会被我们称为 ==falsy== 值，而其他值则被称为 ==truthy==值（包括字符串“0”，“ ”、“false”）等。

接下来，让我们来看看另外两个操作符————逻辑与（&&）和逻辑或（||）的使用示例。当我们使用&& 操作符时，当且仅当该操作所有操作数为 ==true== 时，操作结果才为 ==true== 而 ==||==操作则只需要其中一个操作数为 ==true== ，操作结果即为 ==true==.
```
var b1 = true,b2 = false;
b1 || b2;
// true

b1 && b2;
// false
```
在表 2-3中，我们列出了所有可能的情况及其相应结果。

操作| 结果
---|---
true && true|true
true && false | false
false && true | false
false && false| false
true \|\| true | true
true \|\| false | true
false \|\| true | true
false \|\| false | false

当然，我们也能连续执行若干个逻辑操作。例如：
```
trur && true && false && true
// false

false || true || false;
// true
```
我们还可以在同一个表达式中混合使用&& 和 || 。不过在这种情况下，最后用括号来明确一下操作左右顺序。例如：
```
false && false || true && true;
// true

false && (false || true) && true;
// false
```
### 2.3.4.2 操作符优先级
您可能会想知道，为什么上例中第一个表达式（false && false || true && true）结果为 ==true== 。答案在于 **操作符优先级**。这看上去有点像数学，例如：
```
1 + 2 * 3
// 7
```
由于乘法运算的优先级高于加法，所有该表达式会先计算 ==2 * 3== ，这就相当于我们输入的表达式是：
```
1 + (2 * 3);
// 7 
```
逻辑运算符也一样的， ==!== 的优先级最高，因此在没有括号的情况下它将会被最先执行。接下来的优先级顺序是 ==&&== ,最后才是 || 。也就是说：
``` 
false && false || true && true;
// true
```
与下面表达式等效：
```
(false && false ) || (true && true);
// true
```
> **最佳实践**  
尽量使用括号，而不是依靠操作符优先级来设定代码的执行顺序，这样我们的代码才能有更好的可读性。

尽管 ECMAScript 标准的确对运算符的优先级做了相应的定义，而且记住所有运算符的优先级也算是一种很好的脑力练习，但本书并不打算提供这个优先级列表，因为首先，就算您记住了这些顺序，以后也有可能会忘记。其次，即使您永远不会忘记，您也不应该依赖它，因为别人不一定会记得，这样做会给他们的代码阅读与维护带来困难。

### 2.3.4.3 惰性求值
如果在一个连续的逻辑操作中，操作结果在最后一个操作完成之前就已经明确了的话，那么该操作往往就不必再继续执行了，因为这已经不会对最终结果产生任何影响。例如在下面这种情况中：
```
trur || false || true || false || true
// true
```
在这里，所有的逻辑或运算符优先级都是相同的，只要其中任何一个操作数为 ==true==，该表达式的结果就为 ==true== 。因而当第一个操作数被求值之后，无论后面的值是什么，结果都已经被。于是我们可以允许 ==JavaScript== 引擎偷个懒（好吧，这也是为了提高效率），在不影响最终结果的情况下省略一些不必要的求值操作。为此，我们可以在控制台中做个实验：
```
var b = 5;
true || (b = 6);
// true

b;
// 5

true && (b = 6);
// 6

b;
// 6
```
除引之外，上面的例子还向我们显示了另一个有趣的事情————如果 ==JavaScript== 引擎在一个逻辑表达式中遇到一个非布尔值类型的操作数，那么该操作数的值就会成为该表达式所返回的结果。例如：
```
true || "something";
// true

true && "something";
// "something"

true && something && true;
// true
```
通常情况下，这种行为应该尽量避免，因为它会便我们的代码变得难以理解。但在某些时候这样做也是有用的。例如，当我们不能确定某个变量是否已经被定义时，就可以像下面这样，即如果变量 ==mynumber== 已经被定义了，就保留其析有值，否则就将它初始化为10。
```
var mynumber = mynumber || 10;
mynumber;
// 10
```
这种做法简单面优雅，但是请注意，这也不是绝对安全的。如果这里的 ==mynumber== 之前被初始化为0（或者是那6个 falay 值任何一个），这段代码就不太可能如我们所愿了。
```
var mynumber = 0;
var mynumber = mynumber || 10;
mynumber;
//10
```

### 2.3.4.4 比较运算符
在 ==JavaScript== 中，还有另外一组以布尔值为返回值类型的操作符，即比较操作符。下面让我们能过表 2-4 来了解一下它们以及相关的示例。
**表2-4**

操作符 | 操作说明 | 代码示例
---|---|---
== | 相等运算符：当两个操作数相等时返回==true== 。在该比较操作执行之前，两边的操作数会被自动转换为相同类型|1 == 1;//true  1 == 2;// false   1 == '1';// true
===|严格相等运算符：当且仅且当两个操作数的值和类型都相同时返回 ==true== ，这种比较更可靠，因为其其幕后不存在任何形式的类型转换| 1 === '1';// false   1 === 1;// true
!=|不相等运算符：当两个操作数不相等时返回 ==true==（存在类型转换）| 1 != 1;//false  1 != '1';//false  1 != '2';//true
!==|严格不相等运算符：此操作内不允许类型转换。且当两个操作数的值或类型不相等时返回==true==|1 !== 1;//false  1 !== '1';//true
>|当且仅当左操作数大于右操作数时返回==true== | 1 > 1; //false  33 > 22;//true
>=|当且仅当左操作数大于或等于右操作数时返回==true== | 1 >= 1;//true
 <|当且仅当左操作数小于右操作数时返回==true==| 1 < 1;//false  1 < 2;// true
<=|当且仅当左操作数小于或等于右操作数时返回==true==| 1 <= 1;// true    1 <= 2; //true
还有一件有趣的事情要提醒读者注意：==NaN== 不等于任何东西，包括它自己。
```
NaN == NaN;
//false
```